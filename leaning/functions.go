package main

import "fmt"

func main() {
	slice := []float64{25, 50, 15, 20, 30}
	result := average(slice)
	fmt.Println(result)
}

func average(slice []float64) float64 {
	total := 0.0
	for _, val := range slice {
		total += val
	}
	return total / float64(len(slice))
}

// Существует особая форма записи последнего аргумента в функции Go:

// func add(args ...int) int {
//    total := 0
//    for _, v := range args {
//        total += v
//    }
//    return total
// }
// func main() {
//    fmt.Println(add(1,2,3))
// }

// Использование ... перед типом последнего аргумента означает,
// что функция может содержать ноль и более таких параметров.
// В нашем случае мы берем ноль и более int. Функцию можно вызывать,
// как и раньше, но при этом ей можно передать любое количество аргументов типа int.

// Мы также можем передать срез int-ов, указав ... после среза:

// func main() {
//    xs := []int{1,2,3}
//    fmt.Println(add(xs...))
// }

// Замыкания

// Возможно создавать функции внутри функций:

// func main() {
//    add := func(x, y int) int {
//        return x + y
//    }
//    fmt.Println(add(1,1))
// }

// add является локальной переменной типа func(int, int) int
// (функция принимает два аргумента типа int и возвращает int).
// При создании локальная функция также получает доступ к локальным переменным

// func main() {
//    x := 0
//    increment := func() int {
//        x++
//        return x
//    }
//    fmt.Println(increment())
//    fmt.Println(increment())
// }

// increment прибавляет 1 к переменной x, которая определена в рамках функции main.
// Значение переменной x может быть изменено в функции increment.
// Вот почему при первом вызове increment на экран выводится 1, а при втором — 2.

// Функцию, использующую переменные, определенные вне этой функции, называют замыканием.
// В нашем случае функция increment и переменная x образуют замыкание.

// Один из способов использования замыкания — функция, возвращающая другую функцию,
// которая при вызове генерирует некую последовательность чисел.
// Например, следующим образом мы могли бы сгенерировать все четные числа:
//
// func makeEvenGenerator() func() uint {
//    i := uint(0)
//    return func() (ret uint) {
//        ret = i
//        i += 2
//        return
//    }
// }

// func main() {
//    nextEven := makeEvenGenerator()
//    fmt.Println(nextEven()) // 0
//    fmt.Println(nextEven()) // 2
//    fmt.Println(nextEven()) // 4
// }
//
// makeEvenGenerator возвращает функцию, которая генерирует чётные числа.
// Каждый раз, когда она вызывается, к переменной i добавляется 2,
// но в отличие от обычных локальных переменных её значение сохраняется между вызовами.

// Отложенный вызов, паника и восстановление

// В Go есть специальный оператор defer, который позволяет отложить вызов указанной функции до тех пор,
// пока не завершится текущая. Рассмотрим следующий пример:

// package main

// import "fmt"

// func first() {
//    fmt.Println("1st")
// }
// func second() {
//    fmt.Println("2nd")
// }
// func main() {
//    defer second()
//    first()
// }
//
// Эта программа выводит 1st, затем 2nd. Грубо говоря defer перемещает вызов second в конец функции:

// func main() {
//    first()
//    second()
// }
//
// defer часто используется в случаях, когда нужно освободить ресурсы после завершения.
// Например, открывая файл необходимо убедиться, что позже он должен быть закрыт.
// C defer это выглядит так:

// f, _ := os.Open(filename)
// defer f.Close()

/*
Такой подход дает нам три преимущества:
(1) вызовы Close и Open располагаются рядом, что облегчает понимание программы,
(2) если функция содержит несколько операций возврата (например, одна произойдет в блоке if,
другая в блоке else), Close будет вызван до выхода из функции,
(3) отложенные функции вызываются, даже если во время выполнения происходит ошибка.

Паника и восстановление

Ранее мы создали функцию, которая вызывает panic, чтобы сгенерировать ошибку выполнения.
Мы можем обрабатывать паники с помощью встроенной функции recover.
Функция recover останавливает панику и возвращает значение, которое было передано функции panic.
Можно попытаться использовать recover следующим образом:

package main

import "fmt"

func main() {
    panic("PANIC")
    str := recover()
    fmt.Println(str)
}

Но в данном случае recover никогда не будет вызвана,
поскольку вызов panic немедленно останавливает выполнение функции.
Вместо этого мы должны использовать его вместе с defer:

package main

import "fmt"

func main() {
    defer func() {
        str := recover()
        fmt.Println(str)
    }()
    panic("PANIC")
}

Паника обычно указывает на ошибку программиста (например, попытку получить доступ к
несуществующему индексу массива, забытая и непроинициализированная карта и т.д.)
или неожиданное поведение (исключение), которое нельзя обработать
(поэтому оно и называется «паника»).
*/
