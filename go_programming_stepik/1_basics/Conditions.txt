Условная конструкция if

Конструкция if принимает условие - выражение, которое возвращает значение типа bool.
Если это условие истинно, то выполняется последующий блок инструкций:
package main

import "fmt"

func main() {
   a := 6
   b := 7
   if a < b {
      fmt.Println("a меньше, чем b")
  }
}

If с краткой инструкцией

Так же как и for, оператор if может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные, объявленные в этом блоке, доступны только в области видимости, которая существует до конца if. Пример:
if v := math.Pow(x, n); v < lim {
   // ...
}


Условные конструкции else if и else

Если нам нужно проверить несколько условий, мы можем использовать оператор else if:

if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
}

Если нам нужен вариант, когда ни одно из условий не выполняется, то мы используем оператор else:

if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}


Switch
Предположим, мы захотели написать программу, которая печатала бы английские названия для чисел.
С использованием того, что мы знали до текущего момента, это могло бы выглядеть примерно так:
if i == 0 {
    fmt.Println("Zero")
} else if i == 1 {
    fmt.Println("One")
} else if i == 2 {
    fmt.Println("Two")
} else if i == 3 {
    fmt.Println("Three")
} else if i == 4 {
    fmt.Println("Four")
} else if i == 5 {
    fmt.Println("Five")
}

Но эта запись слишком громоздка. Go содержит в себе другой оператор, позволяющий делать такие вещи проще:
оператор switch (переключатель). С ним программа может выглядеть так:
switch i {
    case 0: fmt.Println("Zero")
    case 1: fmt.Println("One")
    case 2: fmt.Println("Two")
    case 3: fmt.Println("Three")
    case 4: fmt.Println("Four")
    case 5: fmt.Println("Five")
    default: fmt.Println("Unknown Number")
}

Переключатель начинается с ключевого слова switch, за которым следует выражение (в нашем случае i)
и серия возможных значений (case). Значение выражения по очереди сравнивается с выражениями,
следующими после ключевого слова case. Если они оказываются равны, то выполняется действие, описанное после :.

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение,
которое сошлось с выражением. Переключатель также поддерживает действие по-умолчанию,
которое будет выполнено в случае, если не подошло ни одно из возможных значений (напоминает else в операторе if).

В switch можно использовать любой тип данных.

Стоит дополнить, что:
1. В Go код после case выполняется до следующего case, и нет нужды каждый case-блок заканчивать
ключевым словом break (данная особенность добавлена в язык специально, чтобы уменьшить количество
ошибок в switch-блоках). Если в текущем case написать fallthrough, то тело следующего case выполнится
вне зависимости от того истинно ли его (следующего case) условие:

v := 42
switch v {
    case 100:
        fmt.Println(100)
        fallthrough
    case 42:
        fmt.Println(42)
        fallthrough
    case 1:
        fmt.Println(1)
        fallthrough
    default:
        fmt.Println("default")
}
// Вывод:
// 42
// 1
// default

2. Существует специальная форма switch, допускающая использование произвольных условий в каждом case-блоке:

var c uint32
fmt.Scan(&c)
switch {
    case 1 <= c && c <= 9:
        fmt.Println("от 1 до 9")
    case 100 <= c && c <= 250:
        fmt.Println("от 100 до 250")
    case 1000 <= c && c <= 6000:
        fmt.Println("от 1000 до 6000")
}
То есть, сразу после switch "переключатель" не нужен, а после каждого case идет выражение с произвольным условием.